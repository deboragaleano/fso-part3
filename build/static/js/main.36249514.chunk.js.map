{"version":3,"sources":["services/contact.js","Notification.js","Search.js","PersonForm.js","Persons.js","App.js","serviceWorker.js","index.js"],"names":["axios","get","then","resp","data","contact","post","id","delete","newObject","put","Notification","notification","className","type","message","Search","query","onChange","value","PersonForm","name","number","nameChange","addContact","numberChange","onClick","Persons","persons","deleteContact","map","person","key","App","useState","setPersons","newName","setNewName","newNumber","setNewNumber","newSearch","setNewSearch","alert","setAlert","useEffect","contactService","contacts","notify","setTimeout","personsToShow","length","filter","p","toLowerCase","indexOf","e","target","preventDefault","isTheSame","find","window","confirm","returnedContact","updatedPersons","addedPerson","contactToDelete","response","catch","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","console"],"mappings":"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","file":"static/js/main.36249514.chunk.js","sourcesContent":["import axios from 'axios'; \nconst base_URL = '/api/persons' \n\n// all - GET\nconst getContacts = () => {\n    const request = axios.get(base_URL)\n    return request.then(resp => {\n        return resp.data\n    }); \n}\n\n// add - POST \nconst create = (contact) => {\n    const request = axios.post(base_URL, contact)\n    return request.then(resp => resp.data)\n}\n\n// remove - DELETE \nconst remove = (id) => {\n    const request = axios.delete(`${base_URL}/${id}`)\n    return request.then(resp => resp.data)\n}\n\n// update - PUT \nconst update = (id, newObject) => {\n    const request = axios.put(`${base_URL}/${id}`, newObject)\n    return request.then(resp => resp.data)\n}\n\nexport default {getContacts, create, remove, update} \n","import React from 'react'; \n\nconst Notification = ({ notification }) => {\n    if (notification === null) {\n      return null\n    }\n    \n    return (\n      <div className={notification.type}>\n        {notification.message}\n      </div>\n    )\n  }\n\nexport default Notification; ","import React from 'react'; \n\nconst Search = ({query, onChange}) => {\n    return (\n        <input \n          value={query} \n          onChange={onChange}\n        />  \n    )\n}\n\nexport default Search; \n","import React from 'react'; \n\nconst PersonForm = ({name, number, nameChange, addContact, numberChange}) => {\n    return (\n      <form>\n        <div>\n          name: <input value={name} onChange={nameChange}/>\n        </div>\n        <div>\n          number: <input value={number} onChange={numberChange}/>\n        </div>\n        <div>\n          <button onClick={addContact} type=\"submit\">add</button>\n        </div>\n    </form>\n    )\n}\n\nexport default PersonForm; \n  ","import React from 'react'\n\nconst Persons = ({persons, deleteContact}) => {\n    return (\n      persons.map(person => \n      <p key={person.id}>\n        {person.name} {person.number} \n        <button onClick={() => deleteContact(person.id)}>delete</button>\n      </p>\n      )\n    )\n  }\n\nexport default Persons; \n","import React, { useState, useEffect } from 'react'; \nimport contactService from './services/contact'; \nimport Notification from './Notification';\nimport Search from './Search';\nimport PersonForm from './PersonForm';\nimport Persons from './Persons';\n\nconst App = () => {\n  const [ persons, setPersons ] = useState([ ]) \n  const [ newName, setNewName ] = useState('')\n  const [ newNumber, setNewNumber ] = useState('')\n  const [ newSearch, setNewSearch] = useState('')\n  const [ alert, setAlert] = useState(null)\n\n  useEffect(() => {\n    contactService\n      .getContacts()\n      .then(contacts => {\n        setPersons(contacts)\n      })\n  })\n\n  // it takes two args, the message and the type\n  const notify = (message, type='success') => {\n    setAlert({message, type});\n    setTimeout(() => {\n      setAlert(null)\n    }, 4000)\n  }\n\n  const handleNameChange = (e) => {\n    setNewName(e.target.value)\n  }\n  \n  const handleNumberChange = (e) => {\n    setNewNumber(e.target.value)\n  }\n\n  const handleSearchName = (e) => {\n    setNewSearch(e.target.value)\n  }\n\n  const addContact = (e) => {\n    e.preventDefault();\n    const isTheSame = persons.find( p => p.name === newName); \n\n    if(isTheSame) {\n      const isOk = window.confirm(`${newName} is already added to the phonebook, replace the old number with a new one`)\n      if(isOk) {\n        contactService\n        .update(isTheSame.id, {name: isTheSame.name, number: newNumber} )\n        .then(returnedContact => {\n          const updatedPersons = persons.map(p => \n            p.id === isTheSame.id ? returnedContact : p)\n          setPersons(updatedPersons)\n          notify(`Changed number of ${isTheSame.name}`)\n          setNewName(''); \n          setNewNumber(''); \n        })\n      }\n    } else {\n      contactService\n      .create({name: newName, number: newNumber})\n      .then(addedPerson => {\n        // console.log(addedPerson); this is already the new array!\n        // **NOTE: ADDING ANOTHER setPersons created 2 persons array and encountered nasty error with similar ID**\n        // setPersons(persons.concat(addedPerson))\n        notify(`Added ${newName}`)\n        setNewName(''); \n        setNewNumber(''); \n      })\n    }\n  }\n\n  const deleteContact = (id) => {\n    const contactToDelete = persons.find(p => p.id === id)\n    const okToDelete = window.confirm(`delete ${contactToDelete.name}`)\n\n    if(okToDelete) {\n      contactService\n      .remove(id)\n      .then(response => {\n        setPersons(persons.filter(p => p.id !== id))\n        notify(`${contactToDelete.name} deleted`)\n      })\n      .catch(() => {\n        setPersons(persons.filter(p => p.id !== id))\n        notify(`Information of ${contactToDelete.name} has already been removed from server`, 'error')\n      })\n    }\n  }\n\n  const personsToShow = newSearch.length === 0 ?\n    persons : \n    persons.filter(p => p.name.toLowerCase().indexOf(newSearch.toLowerCase()) > 0 )\n\n  return (\n    <div>\n\n      <h1>Phonebook</h1>\n      <Notification notification={alert}/> \n\n      <Search \n        query={newSearch} \n        onChange={handleSearchName}\n      />\n      \n      <h2>Add new</h2>\n      <PersonForm \n        name={newName} \n        number={newNumber} \n        addContact={addContact}\n        nameChange={handleNameChange}\n        numberChange={handleNumberChange}\n      />\n      \n      <h2>Numbers</h2>\n      <Persons \n        persons={personsToShow}\n        deleteContact={deleteContact}\n        />\n    </div>\n  )\n}\n\nexport default App; \n\n/*\nCHANGES SINCE SUBMISSION:\n\n- ADDED notify function to avoid repeating setTimeout \n\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './index.css'; \n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}